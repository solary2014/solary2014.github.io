[{"title":"LauncherModel.Callbacks接口","date":"2017-03-01T02:28:23.434Z","path":"2017/03/01/LauncherModel.Callbacks接口/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public interface Callbacks &#123; //如果Launcher在加载完成之前被强制暂停，那么需要通过这个回调方法通知 //launcher，在它再次显示的时候重新执行加载过程 public boolean setLoadOnResume(); //获取当前用户所在的桌面页索引 public int getCurrentWorkspaceScreen(); //启动桌面组件绑定 public void startBinding(); /** * 批量绑定桌面组件 * @param shortcuts 需要绑定的快捷方式列表 * @param start 列表的开始位置 * @param end 列表的结束位置 * @param forceAnimateIcons 是否使用动画 */ public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAnimateIcons); /** * 批量绑定桌面页 * @param orderedScreenIds 序列化后的桌面页列表 */ public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds); //同上 public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds); /** * 批量绑定文件夹 * @param folders 文件夹映射列表 */ public void bindFolders(LongArrayMap&lt;FolderInfo&gt; folders); //绑定任务完成 public void finishBindingItems(); /** * 往桌面上绑定小部件 * @param info 需要绑定到桌面上的小部件信息 */ public void bindAppWidget(LauncherAppWidgetInfo info); /** * 绑定应用程序列表界面的应用程序信息 * @param apps 需要绑定到应用程序列表中的应用程序列表 */ public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps); /** * 批量添加组件 * @param newScreens 添加的桌面页列表 * @param addNotAnimated 无需动画添加组件 * @param addAnimated 动画方式添加组件 * @param addedApps 添加所有应用程序菜单 */ public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimated, ArrayList&lt;ItemInfo&gt; addAnimated, ArrayList&lt;AppInfo&gt; addedApps); /** * 批量更新应用程序相关的快捷方式或者入口 * @param apps 已经更新的应用程序信息 */ public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps); /** * 从桌面移除一些组件，当应用程序被移除或者禁用的时候调用 * @param packageNames 以包名指定的应用程序信息列表 * @param appInfos 以应用程序信息指定的应用程序信息列表 * @param user 当前用户信息 * @param reason */ public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user); public void bindAllPackages(WidgetsModel model); //全局搜索或者搜索属性更新 public void bindSearchProviderChanged(); /** * * @param rank 输入范围 * @return 是否为应用程序菜单 */ public boolean isAllAppsButtonRank(int rank); /** * 指示正在绑定的页面 * @param page 桌面页序号 */ public void onPageBoundSynchronously(int page); //输出当前Launcher信息到本地文件中 public void dumpLogsToLocalData(); &#125;","tags":[]},{"title":"","date":"2017-03-01T02:28:08.178Z","path":"2017/03/01/android M Launcher之LauncherModel （三）/","text":"通过前两篇的分析，我们已经知道了LauncherModel的初始化及工作流程，如果您还不熟悉的话请看前两篇博文android M Launcher之LauncherModel （一） android M Launcher之LauncherModel （二） 了解了LauncherModel的工作过程后，我们继续来学习LauncherModel中提供的一些工具，从而了解Google工程师在自家系上怎么开发的。 1、线程等待waitForIdle 我们在这个系列第二篇开始讲LoaderTask的run方法时，在加载绑定桌面数据之后，加载与绑定应用程序之前，有一个等待动作即调用了waitForIdle方法，为什么要去调这个方法呢，大家都知道在绑定桌面数据时我们是去UI线程中处理的，接触过应用开发的都知道UI线程正常情况下是不能阻塞的，否则有可能产生ANR，这将严重影响用户体验。所有这里LoaderTask在将结果发送给UI线程之后，为了保证界面绑定任务可以高效的完成，往往会将自己的任务暂停下来，等待UI线程处理完成。不知道大家有没有这样设计过，反正我是没有。从这儿也可以看出Google工程师是比较严谨的。 那我们就来分析下waitForIdle函数是怎么实现的。 首先，创建一个UI线程闲时执行的任务，这个任务负责设置某些关键的控制标志，并将其通过PostIdle方法加入处理器的消息队列中。 1234567891011mHandler.postIdle(new Runnable() &#123; public void run() &#123; synchronized (LoaderTask.this) &#123; mLoadAndBindStepFinished = true; if (DEBUG_LOADERS) &#123; Log.d(TAG, &quot;done with previous binding step&quot;); &#125; LoaderTask.this.notify(); &#125; &#125; &#125;); 这样一来，只有UI线程闲置下来的时候，这里定义的任务才会得到执行，这也就说明了界面已经刷新完成。而一旦这个任务得到执行，就会将mLoadAndBindStepFinished 置为true，以控制即将来临的有条件的无限等待。 最后 设置一个有条件的无限等待，等待来自UI线程的指示。 123456789while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) &#123; try &#123; // Just in case mFlushingWorkerThread changes but we aren&apos;t woken up, // wait no longer than 1sec at a time this.wait(1000); &#125; catch (InterruptedException ex) &#123; // Ignore &#125; &#125; 只要没有中断且加载没有完成这里将一直等待，知道完成，这样看还是很简单的逻辑呀，你有想到么。 2、停止加载工作stopLocked 对于一项任务，有时候我们需要停止它的工作，以保证数据或者流程的正确性。我们看下LoaderTask是怎么做的： 123456public void stopLocked() &#123; synchronized (LoaderTask.this) &#123; mStopped = true; this.notify(); &#125; &#125; 可以看出要停止工作只需将mStopped 置为true， 而LoaderTask在运行过程中会频繁的查询mStopped 标志，所有在开始设置之前需对LoaderTask上锁，以保证mStopped 得到正确的设定，有了上锁就必须有解锁，这就是this.notify();的作用。 3、获取通道 tryGetCallbacks LoaderTask在执行一次加载任务的时候，都毫无意外的需要检验通往Launcher的通道是否存在，或者当前的通道是否经历过重建，如果这样的情况存在，那么LoaderTask久没有继续执行的必要了。 tryGetCallbacks工具的作用就是帮助完成通往Launcher通道的验证。 12345678910111213141516171819202122Callbacks tryGetCallbacks(Callbacks oldCallbacks) &#123; synchronized (mLock) &#123; if (mStopped) &#123; return null; &#125; if (mCallbacks == null) &#123; return null; &#125; final Callbacks callbacks = mCallbacks.get(); if (callbacks != oldCallbacks) &#123; return null; &#125; if (callbacks == null) &#123; Log.w(TAG, &quot;no mCallbacks&quot;); return null; &#125; return callbacks; &#125; &#125; 这里代码应该比较好明白吧。 4、桌面空间判断工具 checkItemPlacement 桌面上的每一个组件想要加载到桌面或者HotSeat，都需要确定当前的桌面或者HotSeat中是否还有足够的空间，checkItemPlacement方法用于完成这个任务。 这个方法分为几步， 获取Launcher属性及item属性 要检查需要处理的项是否有足够的空间，首先要知道当前Launcher有多少空间可以被占用，以及当前的项所处的空间情况， 123456 LauncherAppState app = LauncherAppState.getInstance(); InvariantDeviceProfile profile = app.getInvariantDeviceProfile(); final int countX = profile.numColumns; final int countY = profile.numRows;//被处理项的桌面索引 long containerIndex = item.screenId; 处理被处理项在所处容器的占用情况。主要处理两种情况，一种是HotSeat容器，一种是桌面容器。如果需要处理的是HotSeat容器 ，它需要一些判断，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) &#123; // Return early if we detect that an item is under the hotseat button if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) &#123; Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY + &quot;) occupied by all apps&quot;); return false; &#125; //获取HotSeat容器中空间的占用情况， final ItemInfo[][] hotseatItems = occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT); //如果被处理项要求的位置超过了HotSeat的容量，返回false if (item.screenId &gt;= profile.numHotseatIcons) &#123; Log.e(TAG, &quot;Error loading shortcut &quot; + item + &quot; into hotseat position &quot; + item.screenId + &quot;, position out of bounds: (0 to &quot; + (profile.numHotseatIcons - 1) + &quot;)&quot;); return false; &#125; //如果HotSeat空间已经被Launcher分配 if (hotseatItems != null) &#123; //如果被处理的项所要求的位置已经被占用，返回分配失败 if (hotseatItems[(int) item.screenId][0] != null) &#123; Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY + &quot;) occupied by &quot; + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT) [(int) item.screenId][0]); return false; //如果该空间空闲，则将此空间分配给此项，返回分配成功 &#125; else &#123; hotseatItems[(int) item.screenId][0] = item; return true; &#125; //如果HotSeat空间还没有被分配，分配空间后返回分配成功 &#125; else &#123; //开辟HotSeat空间 final ItemInfo[][] items = new ItemInfo[(int) profile.numHotseatIcons][1]; items[(int) item.screenId][0] = item; //将分配的空间加入占用列表中维护 occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items); return true; &#125; &#125; 如果是桌面容器 123456if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &#123; if (!workspaceScreens.contains((Long) item.screenId)) &#123; // The item has an invalid screen id. return false; &#125; &#125; 其他情况一律返回分配成功。 添加占用列表 如果对应的桌面索引存在，但Launcher并没有在这个桌面页上分配空间，那么Launcher需要为此分配足够的空间： 1234if (!occupied.containsKey(item.screenId)) &#123; ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1]; occupied.put(item.screenId, items); &#125; 判断快捷方式是否有足够的空间 在这里需要判断当前处理的项是否有足够的空间容纳该项，因为该项有可能是一个桌面小部件，可能占用比较大的空间。 123456789101112//获取屏幕上被占用情况 final ItemInfo[][] screens = occupied.get(item.screenId); //如果被处理的项超过范围，则返回分配失败 if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp; item.cellX &lt; 0 || item.cellY &lt; 0 || item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) &#123; Log.e(TAG, &quot;Error loading shortcut &quot; + item + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;); return false; &#125; 检查空间及屏幕占用 有了足够的空间，还需要判断该项需要占用的空间内是否还被其他桌面项（快捷方式 桌面小部件） 占用，如果该项需要的空间范围内只有一块被占用也属于分配失败。 12345678910111213// Check if any workspace icons overlap with each other for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) &#123; for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) &#123; if (screens[x][y] != null) &#123; Log.e(TAG, &quot;Error loading shortcut &quot; + item + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot; + x + &quot;,&quot; + y + &quot;) occupied by &quot; + screens[x][y]); return false; &#125; &#125; &#125; 让被处理的项占用它需要的空间 12345for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) &#123; for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) &#123; screens[x][y] = item; &#125; &#125; 6、桌面组件的排序工具sortWorkspaceItemsSpatially 在Launcher中，在绑定桌面组件之前都需要对桌面组件进行一次排序，原则上是Y轴方向从上到下，X轴从左到右 1234567891011121314151617final LauncherAppState app = LauncherAppState.getInstance(); final InvariantDeviceProfile profile = app.getInvariantDeviceProfile(); // XXX: review this Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() &#123; @Override public int compare(ItemInfo lhs, ItemInfo rhs) &#123; int cellCountX = (int) profile.numColumns; int cellCountY = (int) profile.numRows; int screenOffset = cellCountX * cellCountY; int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset + lhs.cellY * cellCountX + lhs.cellX); long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset + rhs.cellY * cellCountX + rhs.cellX); return (int) (lr - rr); &#125; &#125;); 这个是java对一个数组的排序方式。 以上就是LoaderTask提供的一些重要工具，通过学习Google的源码我们也可以把它应用到实际的开发中去，提高自己代码的健壮性。 好了，从第一篇开始到这篇结束，我们终于把LauncherModel的整个工作流程走了一遍。以下是整个LauncherModel系列的索引 一 、LauncherModel的的实例化二 、 LauncherModel数据的加载流程 三 、LauncherModel中一些工具的介绍","tags":[]},{"title":"","date":"2017-03-01T02:27:48.257Z","path":"2017/03/01/android M Launcher之LauncherModel （二）/","text":"上一篇我们通过LauncherModel的创建 ，实例化，以及与LauncherModel之间的沟通方式。初步了解了LauncherModel一些功能及用法，如果对LauncherModel一系列初始化动作还不了解的可以看 android M Launcher之LauncherModel （一） 好了 接下来我们继续分析，大家都知道 LauncherModel是Launcher的数据中心，但是数据中心的数据是怎么加载出来的呢，这里就要说到LoaderTask了，它是LauncherModel的核心任务。 1、LoaderTask的定义、属性及构造 要了解一个类的功能和作用，我们通常从该类的定义及其定义的成员变量开始，就好比了解一个人最先看到的肯定是他的外貌了。 123456private class LoaderTask implements Runnable &#123; private Context mContext; boolean mIsLoadingAndBindingWorkspace; private boolean mStopped; boolean mLoadAndBindStepFinished; &#125; 由定义可以看出LoaderTask是一个实现Runnable 接口的类，我们都知道Runnable 是一个任务，它可以被抛到线程中执行，也可以被抛到进程的处理器中执行，通过实现Runnable接口来实现多线程以及线程间的通信是比较常用的做法。 LoaderTask的执行需要Launcher应用程序提供必要的支持，而外界也需要知道Loaderask的执行状态，因此在LoaderTask中，以成员变量的方式保存了LoaderTask执行所必需的支持以及自身相关的状态。 mIsLoadingAndBindingWorkspace ：它是LoaderTask执行动作的指示性变量，当正在加载和绑定桌面数据时它为true，当动作执行完成后它为false。 mStopped ：标示整个加载任务是否已经被强制停止，LoaderTask对外提供了一个停止加载的接口，如果外部通过这个接口来停止一个加载任务，那么它将为true，默认是false mLoadAndBindStepFinished ： 通过它可以知道整个加载任务所涉及的动作已经执行完毕 2、LoaderTask的run接口实现LoaderTask是一个Run那边了接口的实现，每一个Runnable接口的实现都需要实现run方法，LoaderTask也不例外，当LoaderTask作为一个任务在某一个线程中运行时，实际就是这个线程调用了它的run方法 123456789101112131415161718192021222324252627282930313233343536373839public void run() &#123; synchronized (mLock) &#123; if (mStopped) &#123; return; &#125; mIsLoaderTaskRunning = true; &#125; // Optimize for end-user experience: if the Launcher is up and // running with the // All Apps interface in the foreground, load All Apps first. Otherwise, load the // workspace first (default). keep_running: &#123; if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;); loadAndBindWorkspace(); if (mStopped) &#123; break keep_running; &#125; waitForIdle(); // second step if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;); loadAndBindAllApps(); &#125; // Clear out this reference, otherwise we end up holding it until all of the // callback runnables are done. mContext = null; synchronized (mLock) &#123; // If we are still the last one to be scheduled, remove ourselves. if (mLoaderTask == this) &#123; mLoaderTask = null; &#125; mIsLoaderTaskRunning = false; mHasLoaderCompletedOnce = true; &#125; &#125; 这里主要做了两件事1、loading workspace2、loading all apps其他的就是一些成员变量的赋值。 首先loading workspace 我们画流程图来看： 123456789101112131415161718192021private void loadAndBindWorkspace() &#123; mIsLoadingAndBindingWorkspace = true; // Load the workspace if (DEBUG_LOADERS) &#123; Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded); &#125; if (!mWorkspaceLoaded) &#123; loadWorkspace(); synchronized (LoaderTask.this) &#123; if (mStopped) &#123; return; &#125; mWorkspaceLoaded = true; &#125; &#125; // Bind the workspace bindWorkspace(-1); &#125; 结合上面代码 可以发现 它又分为两步1、生成桌面数据loadWorkspace；2、绑定桌面配置数据bindWorkspace。 loadWorkspace Launcher桌面的数据主要包括来自Launcher数据库的各种表，loadWorkspace方法将负责从这些数据库表中读取数据并转译为Launcher桌面项的数据结构。这个代码比较多同样先上流程图。 获取系统服务一节设备属性并调整桌面页顺序 在加载数据桌面数据前，loadWorkspace 方法必需获取到必要的支持，因为loadWorkspace方法主要处理应用程序包的相关信息，所以首先要获取包管理服务，其次 需要确定快捷方式或者桌面小部件的位置，因此它还需要获取屏幕的宽和高代码如下： 12345678910111213141516171819202122232425262728293031323334final Context context = mContext; final ContentResolver contentResolver = context.getContentResolver(); //获取包管理服务，并查询当前是否处于安全模式 final PackageManager manager = context.getPackageManager(); final boolean isSafeMode = manager.isSafeMode(); //获取Launcher定制的应用程序管理接口 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context); final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver.SYSTEM_READY)) != null; //获取桌面有多少行，多少列 LauncherAppState app = LauncherAppState.getInstance(); InvariantDeviceProfile profile = app.getInvariantDeviceProfile(); int countX = profile.numColumns; int countY = profile.numRows; if (MigrateFromRestoreTask.ENABLED &amp;&amp; MigrateFromRestoreTask.shouldRunTask(mContext)) &#123; long migrationStartTime = System.currentTimeMillis(); Log.v(TAG, &quot;Starting workspace migration after restore&quot;); try &#123; //根据实际情况调整桌面页的顺序 MigrateFromRestoreTask task = new MigrateFromRestoreTask(mContext); // Clear the flags before starting the task, so that we do not run the task // again, in case there was an uncaught error. MigrateFromRestoreTask.clearFlags(mContext); task.execute(); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Error during grid migration&quot;, e); // Clear workspace. mFlags = mFlags | LOADER_FLAG_CLEAR_WORKSPACE; &#125; Log.v(TAG, &quot;Workspace migration completed in &quot; + (System.currentTimeMillis() - migrationStartTime)); &#125; 根据输入的标志对数据进行必要的预处理在不同的场景下，LoadWorkspace可能要对需要处理的数据来源进行必要的处理，这取决于mFlags 标志，代码如下： 12345678910//如果mFlags中包含LOADER_FLAG_CLEAR_WORKSPACE，则清理原有的数据 if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) &#123; Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true); LauncherAppState.getLauncherProvider().deleteDatabase(); &#125; // Make sure the default workspace is loaded //确保默认数据得以加载 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false); LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(); 清理历史数据并准备必要数据在每次加载桌面数据时，需要对这些数据区域进行清理 这个平时我们往listview中添加数据前要清理一样的道理， 它主要在clearSBgDataStructures 中完成 123456789101112/** * Clears all the sBg data structures */ private void clearSBgDataStructures() &#123; synchronized (sBgLock) &#123; sBgWorkspaceItems.clear();//清理桌面项列表 sBgAppWidgets.clear();//清理桌面快捷方式列表 sBgFolders.clear();//清理文件夹数据列表 sBgItemsIdMap.clear();//清理桌面项字段 sBgWorkspaceScreens.clear();//清理桌面页记录列表 &#125; &#125; 完成清理后loadWorkspace方法需要知道当前设备中安装了多少应用程序，除了这些外，在加载桌面桌面数据的过程中会产出一些过程数据，他们保持在其他区域代码如下： 123456final HashMap&lt;String, Integer&gt; installingPkgs = PackageInstallerCompat .getInstance(mContext).updateAndGetActiveSessionCache(); sBgWorkspaceScreens.addAll(loadWorkspaceScreensDb(mContext)); final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;(); final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;(); 有了上面这些基础后 ，接下来就开始加载数据了。 查询Favorites表数据库并准备桌面占用情况标志映射 12345678final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI; if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri); final Cursor c = contentResolver.query(contentUri, null, null, null, null); // +1 for the hotseat (it can be larger than the workspace) // Load workspace in reverse order to ensure that latest items are loaded first (and // before any earlier duplicates) final LongArrayMap&lt;ItemInfo[][]&gt; occupied = new LongArrayMap&lt;&gt;(); 从Cursor中获取桌面项类型itemType等数据项 123int itemType = c.getInt(itemTypeIndex);//桌面项类型 boolean restored = 0 != c.getInt(restoredIndex);//是否已经恢复 boolean allowMissingTarget = false; 应用程序入口及其他入口快捷方式的处理 在这里Launcher需要处理桌面上快捷方式的记录，将其转换成Launcher可以处理的对象。如下图 处理文件夹记录处理 桌面文件只需要处理好文件夹的标题，位置以及所处的容器即可。 桌面小部件记录处理 这里或处理桌面快捷方式类似，可以参考处理桌面快捷方式的流程来看处理桌面小部件。 从数据库中清理需要删除的数据项通过以上处理步骤，可能产生依稀需要删除的记录如下： 123456789101112131415161718192021222324252627282930313233if (itemsToRemove.size() &gt; 0) &#123; // Remove dead items contentResolver.delete(LauncherSettings.Favorites.CONTENT_URI, Utilities.createDbSelectionQuery( LauncherSettings.Favorites._ID, itemsToRemove), null); if (DEBUG_LOADERS) &#123; Log.d(TAG, &quot;Removed = &quot; + Utilities.createDbSelectionQuery( LauncherSettings.Favorites._ID, itemsToRemove)); &#125; // Remove any empty folder for (long folderId : LauncherAppState.getLauncherProvider() .deleteEmptyFolders()) &#123; sBgWorkspaceItems.remove(sBgFolders.get(folderId)); sBgFolders.remove(folderId); sBgItemsIdMap.remove(folderId); &#125; &#125; // Sort all the folder items and make sure the first 3 items are high resolution. for (FolderInfo folder : sBgFolders) &#123; Collections.sort(folder.contents, Folder.ITEM_POS_COMPARATOR); int pos = 0; for (ShortcutInfo info : folder.contents) &#123; if (info.usingLowResIcon) &#123; info.updateIcon(mIconCache, false); &#125; pos++; if (pos &gt;= FolderIcon.NUM_ITEMS_IN_PREVIEW) &#123; break; &#125; &#125; &#125; 置恢复状态为以恢复有些记录可能来自备份与恢复的过程，如果当前处理的记录属于这种，并且已经得到完整的恢复那么这些记录ID都会被缓存在restoredRows中，在处理往需要删除的记录后，就要将restoredRows中指定记录恢复状态置为0. 12345678if (restoredRows.size() &gt; 0) &#123; // Update restored items that no longer require special handling ContentValues values = new ContentValues(); values.put(LauncherSettings.Favorites.RESTORED, 0); contentResolver.update(LauncherSettings.Favorites.CONTENT_URI, values, Utilities.createDbSelectionQuery( LauncherSettings.Favorites._ID, restoredRows), null); &#125; 处理安装在SDCARD上的应用程序 12345if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) &#123; context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceiver.SYSTEM_READY), null, sWorker); &#125; 当sPendingPackages中有了记录并且SDCARD没有挂载好的时候，Launcher注册相关的广播接收器等待SDCARD的挂载完成。 好了 LoadWorkspace分析就完成了，真心不容易呀。 再接再厉 我们看bindWorkspace 上面我们已经准备好了需要加载的数据，那么接下来需要做的就是将这些数据发送到Launcher，让它将这些数据转化为一个个可以显示的view，这个过程由bindWorkspace来完成。 1private void bindWorkspace(int synchronizeBindPage) synchronizeBindPage 如果它的值小于0说明需要对所有桌面页进行刷新，如果大于等于0，则对指定页进行刷新。 在画图看下bindWorkspace的流程。发现Xmind用的越来越6了 O(∩_∩)O哈哈~ 在加载桌面数据的过程中，已经把需要加载的数据分门别类的放在不同的数据缓冲区。由于LauncherModel的LoaderTask可以因为LauncherModel执行不同的任务而被多次实例化，这将会引起缓冲区数据共享问题，为了解决这个问题每次绑定数据的时候都要临时将数据缓冲区的数据备份，代码如下： 1234567891011121314151617181920212223242526272829303132// Save a copy of all the bg-thread collections //桌面数据项列表 ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;(); //桌面小部件数据项列表 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;(); //经过排序的桌面页索引列表 ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;(); final LongArrayMap&lt;FolderInfo&gt; folders; final LongArrayMap&lt;ItemInfo&gt; itemsIdMap; //缓冲区数据复制 synchronized (sBgLock) &#123; workspaceItems.addAll(sBgWorkspaceItems); appWidgets.addAll(sBgAppWidgets); orderedScreenIds.addAll(sBgWorkspaceScreens); folders = sBgFolders.clone(); itemsIdMap = sBgItemsIdMap.clone(); &#125; //获取Launcher当前所处的页面索引 final boolean isLoadingSynchronously = synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE; int currScreen = isLoadingSynchronously ? synchronizeBindPage : oldCallbacks.getCurrentWorkspaceScreen(); if (currScreen &gt;= orderedScreenIds.size()) &#123; // There may be no workspace screens (just hotseat items and an empty page). currScreen = PagedView.INVALID_RESTORE_PAGE; &#125; final int currentScreen = currScreen; final long currentScreenId = currentScreen &lt; 0 ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen); 分离当前页面与其他页面的数据并通知Launcher加载开始 123456789101112131415161718192021222324252627282930313233// Separate the items that are on the current screen, and all the other remaining items //分类数据区定义 ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;(); ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;(); ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;(); ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;(); LongArrayMap&lt;FolderInfo&gt; currentFolders = new LongArrayMap&lt;&gt;(); LongArrayMap&lt;FolderInfo&gt; otherFolders = new LongArrayMap&lt;&gt;(); //分类桌面项数据 filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWorkspaceItems); //分类小部件数据 filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets, otherAppWidgets); filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders, otherFolders); //对数据进行排序 sortWorkspaceItemsSpatially(currentWorkspaceItems); sortWorkspaceItemsSpatially(otherWorkspaceItems); // Tell the workspace that we&apos;re about to start binding items //在主线程上执行通知Launcher绑定开始任务 r = new Runnable() &#123; public void run() &#123; Callbacks callbacks = tryGetCallbacks(oldCallbacks); if (callbacks != null) &#123; callbacks.startBinding(); &#125; &#125; &#125;; runOnMainThread(r); LoaderTask在绑定数据的过程中会产生不同的过程状态信息，这些信息会通过回调接口通知LauncherModel对数据处理的状态信息，比如绑定数据之前，会通过 startBinding接口通知Launcher准备开始绑定数据，在绑定数据结束时通过Launcher实现的finishBindingItems通知Launcher数据绑定完成等。这些回调方法的实现绝大多数需要处理界面上的view因此他们都需要在UI线程中。 通过结束绑定为例来说明下这个过程： 12345678910111213141516171819202122232425262728293031323334353637// Tell the workspace that we&apos;re done binding items //实现包含了结束绑定通知的任务 r = new Runnable() &#123; public void run() &#123; Callbacks callbacks = tryGetCallbacks(oldCallbacks); if (callbacks != null) &#123; callbacks.finishBindingItems(); &#125; //设置加载以及绑定任务结束标志 mIsLoadingAndBindingWorkspace = false; // Run all the bind complete runnables after workspace is bound. if (!mBindCompleteRunnables.isEmpty()) &#123; synchronized (mBindCompleteRunnables) &#123; for (final Runnable r : mBindCompleteRunnables) &#123; runOnWorkerThread(r); &#125; mBindCompleteRunnables.clear(); &#125; &#125; // If we&apos;re profiling, ensure this is the last thing in the queue. if (DEBUG_LOADERS) &#123; Log.d(TAG, &quot;bound workspace in &quot; + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;); &#125; &#125; &#125;; if (isLoadingSynchronously) &#123; synchronized (mDeferredBindRunnables) &#123; mDeferredBindRunnables.add(r); &#125; &#125; else &#123; //在主线程中执行该任务 runOnMainThread(r); &#125; 在完成了上面一系列操作后，最新的数据就完成了从数据库记录到桌面上可见的图标的转换。 终于到loading all apps了它的实现方法为loadAndBindAllApps() 这个方法没有参数也没有返回值 它只是一个主干通过调用其他两个方法来完成应用程序猜的的数据加载及绑定。 加载所有应用程序菜单的过程和加载桌面的过程一样，都是由加载数据和绑定数据。当第一次对应用程序菜单数据进行处理的时候，需要将这两个过程整合执行，如果之前已经加载了应用程序加载任务，只需要执行绑定动作。 和加载桌面一样 我们首先看下loadAllApps() 获取账户并清理缓存 android系统提供了多账户的概念，不同的账户下可以使用的应用程序是不同的，因此Launcher需要注意这个细节，在不同账户下处理不同的应用程序列表信息，所有在加载应用程序列表的时候需要获取当前设备上的所有账户。 1234final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles(); // Clear the list of apps mBgAllAppsList.clear(); 获取应用程序入口信息 Android5.0后提供了LauncherApps的服务，所以只需要通过LauncherApps就可以获取到应用程序的入口信息了 1final List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user); 将应用程序信息加入缓存区 到这里，LauncherModel就查询到了需要处理的数据，为了提高效率LauncherModel队这些数据提供了临时保存的缓存区 如下代码： 1234567891011 // Create the ApplicationInfos for (int i = 0; i &lt; apps.size(); i++) &#123; LauncherActivityInfoCompat app = apps.get(i); // This builds the icon bitmaps. mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache)); &#125;``` - **按账户保存查询到的应用列表**通过ManagedProfileHeuristic工具将查询到的数据分类保存到共享文件中如下代码： //创建与该用户相关联的筛选器实例 final ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(mContext, user); if (heuristic != null) { //创建按账户分类应用程序的任务 final Runnable r = new Runnable() { @Override public void run() { heuristic.processUserApps(apps); } }; //在UI线程中执行这个任务 runOnMainThread(new Runnable() { @Override public void run() { // Check isLoadingWorkspace on the UI thread, as it is updated on // the UI thread. if (mIsLoadingAndBindingWorkspace) { synchronized (mBindCompleteRunnables) { mBindCompleteRunnables.add(r); } } else { runOnWorkerThread(r); } } }); 1234 - **绑定应用程序菜单数据**将需要加载到应用程序菜单中的数据完成分类后，紧接着就需要将数据发送到Launcher中处理 如下： mHandler.post(new Runnable() { public void run() { final long bindTime = SystemClock.uptimeMillis(); final Callbacks callbacks = tryGetCallbacks(oldCallbacks); if (callbacks != null) { callbacks.bindAllApplications(added); if (DEBUG_LOADERS) { Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot; + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;); } } else { Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;); } } }); ``` 剩下的onlyBindAllApps()方法做的事情 和上面的绑定应用程序菜单数据是一样的。 OK 至此我们已经把加载绑定桌面和应用程序的流程都走完了。好累","tags":[]},{"title":"","date":"2017-03-01T02:27:29.948Z","path":"2017/03/01/android M Launcher之LauncherModel （一）/","text":"众所周知 LauncherModel在Launcher中所占的位置，它相当于Launcher的数据中心，Launcher的桌面以及应用程序菜单中所需的数据像 桌面小部件的信息、快捷方式信息、文件信息、以及一些比较特殊的桌面页的信息等都是由它提供，因此我们这里来分析下LauncherModel的工作流程。 一、LauncherModel的创建 要了解LauncherModel，我们要从LauncherModel的实例化开始。LauncherModel是在Launcher应用程序被创建的时候，由LauncherApplication通过调用LauncherAppState的初始化方法实现的，即由LauncherAppState的getInstance方法调用LauncherAppState的构造方法来实现，因此我们需要去看下LauncherAppState的构造方法 1、创建LauncherModel的准备工作 LauncherModel作为中心枢纽，不可避免的要与大量的图片打交道。这些图片包括Launcher所管理的医用程序图标，以及一些桌面小部件的预览图标，Launcher为他们准备了一个图片缓存区（IconCache），因此LauncherModel首先需要持有IconCache的实例，另外，如果Launcher并不希望那么多的应用程序展示在其中，所以它还需要一个应用程序的筛选器实例（AppFilter）。于是，LauncherModel的准备工作实际上就是IconCache和AppFilter的创建过程。123456 mIconCache = new IconCache(sContext, mInvariantDeviceProfile); ... mAppFilter = AppFilter.loadByName(sContext.getString(R.string.app_filter_class));... 中间的代码都省略一下只看和Launchermodel有关的。 2、创建LauncherModel的实例 在完成了以上准备工作后，就可以进行LauncherModel的实例创建了 1mModel = new LauncherModel(this, mIconCache, mAppFilter); 3、LauncherModel的一些设置 LauncherModel本身是一个广播接收器的子类，LauncherAppState在创建的时候会为它设置一些广播，以便让LauncherModel的实例能够处理自己的广播： 123456789// Register intent receivers IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_LOCALE_CHANGED); filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED); // For handling managed profiles filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED); filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED); sContext.registerReceiver(mModel, filter); 从上面代码可以看出，LauncherModel本身需要关注设备的语种，设备配置变化以及搜索相关的变化，这是因为Launcher需要根据设备配置信息的改变来改变加载在桌面的图标、标题的信息，例如语言改变后 Launcher会马上生效。 到这里 LauncherModel的创建过程就完成了，接下来看下LauncherModel的构造函数。 二 、LauncherModel的构造函数 上图展示了LauncherModel的创建过程，可以看出LauncherModel的运行需要依赖一些条件。如下 1、有些应用程序会通过其配置把自己安装到外部存储器上，因此Launcher在管理应用程序的时候就需要额外关注这个存储器是否是一个可以被移除的设备 1mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable(); isExternalStorageRemovable这个方法将返回这个外部存储器的性质。 2、Launcher3是在Android4.4以后才提供的全新桌面应用程序，因此我们需要考虑从Launcher2的升级，其中一个重要的部分就是将Launcher2的数据库数据迁移并升级到Launcher3中，并适配Launcher3的数据库结构。在Launcher3中通过字符串的配置将Launcher2数据库的URL保持起来后，LauncherModel在创建的时候通过此字符串的配置获取访问Launcher2数据库的URL，如下 1String oldProvider = context.getString(R.string.old_launcher_provider_uri); 3、有了访问Launcher2数据库的URL，接下来要做的是判断Launcher2的数据库是否还存在。 12345678910111213// This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different // resource string. //获取Launcher2数据库的Author信息 String redirectAuthority = Uri.parse(oldProvider).getAuthority(); //通过特定的Author获取特定的数据库组件信息 ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0); ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthority, 0); Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider); //判断Launcher2的数据库组件是否存在 mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null); 这里主要的目的是通过mOldContentProviderExists 保持当前是否存在Launcher2数据库组件，因为只有这些组件存在，才可以保证Launcher2数据库存在。 4、最后LauncherModel还需要保持一些对于自身工作有着深远影响的信息，如图片缓存区、用户管理器等信息 1234567891011//保存Launcher的运行状态 mApp = app; //支持后台加载数据的列表 mBgAllAppsList = new AllAppsList(iconCache, appFilter)； //图片缓存 mIconCache = iconCache; //应用程序兼容管理器 mLauncherApps = LauncherAppsCompat.getInstance(context); //保存当前用户管理器 mUserManager = UserManagerCompat.getInstance(context); 到这里LauncherModel就实例化完成了，当LauncherAppState实例化流程完成后，LauncherModel就可以投入运行，等待来自其他组件的调度。 三、与LauncherModel的沟通方式 LauncherModel作为Launcher的中心枢纽，它给Launcher的各个组件提供了三类借口，以便更新Launcher的界面等信息，这些借口包括LauncherModel操作的回调借口，广播接口和应用程序内部接口。 1、LauncherModel操作的回调接口 LauncherModel操作的回调接口主要使用在一下场景中。 Launcher在启动时，需要桌面的数据，这些数据的形成需要由LauncherModel完成，在数据不断被完善的过程中，LauncherModel需要通过这些接口输送已经完成的数据 在Launcher使用的过程中，我们可能会改变桌面上的元素配置，比如手动往桌面上添加快捷方式，每一次操作也无一例外的需要通过LauncherModel来完成。操作完成后LauncherModel也需要通过这些接口通知界面更新。 第三方应用程序通过Launcher提供的接口往桌面上添加或者从桌面上删除摸个快捷方式，这个操作由Launcher提供的广播接收器将请求转发到LauncherModel来处理，LauncherModel完成相关数据处理后，将会通过这些接口通知界面更新。 以上就是这些回调接口的作用以及使用场景，需要注意的是，这些接口并非由LauncherModel实现，而是由Launcher的组件实现并注册到LauncherModel中，从而实现这样的沟通机制。 下面分析Launcher怎么注册到LauncherModel中 ① 注册回调接口 在Launcher中，很多组件都需要与LauncherModel建立联系，而这些联系多数是通过Launcher的主Activity（Launcher.java）来实现的，因此Launcher需要实现LauncherModel的回调接口，LauncherModel在执行某个操作的时候，会将执行的过程和结果通过回调的方式告诉Launcher，下面看下Launcher是如何将接口注册到LauncherModel中。 Launcher的入口Activity在创建的时候，通过LauncherAppState的setLauncher方法开始注册接口的过程，如下 1mModel = app.setLauncher(this); LauncherAppState的setLauncher方法除了完成注册以外，还将LauncherModel实例的引用返回到Launcher。 在LauncherAppState的setLauncher方法中调用LauncherModel的initialize方法，将接口实现的引用注册到LauncherModel中，并返回已经完成初始化的LauncherModel的引用。比较绕口 看代码就明白 1234567LauncherModel setLauncher(Launcher launcher) &#123; getLauncherProvider().setLauncherProviderChangeListener(launcher); mModel.initialize(launcher); mAccessibilityDelegate = ((launcher != null) &amp;&amp; Utilities.ATLEAST_LOLLIPOP) ? new LauncherAccessibilityDelegate(launcher) : null; return mModel; &#125; 在LauncherModel的initialize方法中，实际上只是使用Launcher的接口实现部分，并将接口实现的引用放在一个弱引用中，从而完成初始化过程如下 12345678public void initialize(Callbacks callbacks) &#123; synchronized (mLock) &#123; // Disconnect any of the callbacks and drawables associated with ItemInfos on the // workspace to prevent leaking Launcher activities on orientation change. unbindItemInfosAndClearQueuedBindRunnables(); mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks); &#125; &#125; 这样Launcher和LauncherModel中的回调方法就建立起了联系，LauncherModel的所有操作结果都会通过callbacks中定义的各个回调接口中的方法通知给Launcher，并由Launcher分发给不同的桌面组件或者Launcher自身。 ② 回调接口的定义上面了解了接口的注册过程，接下来我们看下接口的具体内容。在LauncherModel中定义了一个名叫callbacks的接口，它体现了Launchermodel在操作的过程中可能产生的中间过程以及动作，方便LauncherModel获取实现方的运行状态以决定其操作的过程。每个以接口的含义请参考这篇博客 LauncherModel.Callbacks接口 2、广播接口 系统也可以通过发送广播来驱动LauncherModel工作，当LauncherModel接收到一些广播的时候，会启动界面刷新。LauncherModel本身就是一个广播接收器，根据Android的管理，LauncherModel通过自身实现的OnReceive方法来接收来自不同地方的广播 123456789101112131415161718public void onReceive(Context context, Intent intent) &#123; if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent); final String action = intent.getAction(); if (Intent.ACTION_LOCALE_CHANGED.equals(action)) &#123; // If we have changed locale we need to clear out the labels in all apps/workspace. forceReload(); &#125; else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action)) &#123; Callbacks callbacks = getCallback(); if (callbacks != null) &#123; callbacks.bindSearchProviderChanged(); &#125; &#125; else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action) || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) &#123; UserManagerCompat.getInstance(context).enableAndResetCache(); forceReload(); &#125; &#125; 对于LauncherModel来说，系统的语言配置属性变化或者设备中的mcc码配置发生了改变，需要对桌面上的组件产生影响，例如，当语言配置属性发生改变的时候，设备上的显示信息需要更新成相应的语言，因此我们需要对Launcher管理的应用程序的快捷方式等桌面组件进行一次整体更新。 3、LauncherModel的应用程序级别接口 LauncherModel作为Launcher的枢纽，绝大多数时间是在处理Launcher应用程序通过调用LauncherModel的接口发来的请求，比如当第三方应用程序安装通过接口往桌面上添加快捷方式的时候，当用户安装或者卸载某个应用程序的时候，以及当Launcher启动初期时，都需要LauncherModel为Launcher应用程序提供必要的接口以及正确的数据。 下面按接口来看下他们的实现 ① 启动加载任务startLoader这是一个用于指示LauncherModel进行桌面以及应用程序菜单数据加载的接口。Launcher在启动或者被恢复的时候，Launcher都会通过这个接口来进行数据加载。他的声明如下 1public void startLoader(int synchronousBindPage, int loadFlags) &#123;&#125;； 它没有返回值，因为在加载的过程中，会通过Launcher注册的回调接口得到数据处理的中间过程输入参数的含义 synchronousBindPage 这是一个整型的输入参数，调用方通过定制这个参数的值来指示LauncherModel加载对应的桌面页数据，当输入-1001时（在pageview中定义）将会对当前Launcher上维护的所有桌面页上的数据进行加载。 loadFlags 这是一个整型的输入参数，调用者通过这个参数来指示LauncherModel的加载任务应该执行的动作，LauncherModel提供了3中不同的选项 LOADER_FLAG_CLEAR_WORKSPACE 用于指示LauncherModel对synchronousBindPage 参数指定的桌面数据进行清理 LOADER_FLAG_MIGRATE_SHORTCUTS 用于指示LauncherModel对Launcher2的快捷方式数据进行迁移。 LOADER_FLAG_NONE 用于指示LauncherModel对Launcher3的桌面数据进行一次加载或者刷新。 12345678910111213141516171819202122232425public void startLoader(int synchronousBindPage, int loadFlags) &#123; // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems InstallShortcutReceiver.enableInstallQueue(); synchronized (mLock) &#123; // Clear any deferred bind-runnables from the synchronized load process // We must do this before any loading/binding is scheduled below. synchronized (mDeferredBindRunnables) &#123; mDeferredBindRunnables.clear(); &#125; // Don&apos;t bother to start the thread if we know it&apos;s not going to do anything if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) &#123; // If there is already one running, tell it to stop. stopLoaderLocked(); mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags); if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) &#123; mLoaderTask.runBindSynchronousPage(synchronousBindPage); &#125; else &#123; sWorkerThread.setPriority(Thread.NORM_PRIORITY); sWorker.post(mLoaderTask); &#125; &#125; &#125; &#125; 具体实现如上。在Launcher内部，所有的桌面数据的操作请求都通过这个方法来处理，因此startLoader需要保证在多个请求并发的情况。正是基于这个原因LauncherModel的startLoader方法的方法体都被包含在一个同步块中。 Launcher和LauncherModel之间的交互式是以类似消息驱动的方式进行的。LauncherModel产生的消息通过Launcher注册到LauncherModel中的回调接口，并得到通知。而当LauncherModel完成一次加载的时候，通过finishBindingItems接口通知Launcher加载已经完成，如果当前只是对桌面的某一个页面进行数据刷新，那么这个接口的调用会被封装成为一个任务加载到一个消息队列中，等待后续所有的任务完成后才统一执行，如果这个任务还没有得到执行，而新的刷新页面的请求已经到来，那么LauncherModel在启动加载之前会将消息队列清空，以确保所在任务都执行完成后。Launcher才会得到通知具体实现如下： 123synchronized (mDeferredBindRunnables) &#123; mDeferredBindRunnables.clear(); &#125; mDeferredBindRunnables是一个Runable的列表，当LauncherModel的加载任务完成后，这里将会保存发往Launcher的通知，封装在一个Runable中加入该列表。 接下来LauncherModel将决策加载任务(LoaderTask）的执行方式是即时执行环视线程调度执行。如果LauncherModel接收到的是对指定页面的刷新任务，LauncherModel还需要对应用程序菜单及桌面数据的加载完成情况做判断，如果他们的数据都已经加载完成则当前加载任务将会即时执行。 1mLoaderTask.runBindSynchronousPage(synchronousBindPage); 如果当前选择的是对所有桌面页数据进行加载这类大量数据的请求，或者桌面以及应用程序菜单的数据的加载工作并未完成，那么这个任务将会被放置在lauModel创建的线程的线程队列中等待执行 12sWorkerThread.setPriority(Thread.NORM_PRIORITY); sWorker.post(mLoaderTask); ② 停止加载 LauncherModel在需要停止加载任务的时候通过调用stopLoaderLocked方法来完成。 123456private void stopLoaderLocked() &#123; LoaderTask oldTask = mLoaderTask; if (oldTask != null) &#123; oldTask.stopLocked(); &#125; &#125; 它是LauncherModel的一个工具不对外公开，不需要任何参数，只负责将正在运行的任务停掉。 ③ LauncherModel的工作线程 在LauncherModel中定义了一个静态线程变量sWorkerThread，所有需要等待加载的任务都被抛到该线程的队列中等待处理 1234@Thunk static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;); static &#123; sWorkerThread.start(); &#125; 这样设计能确保sWorkerThread 在LauncherModel类被加载的时候就已经存在，并处于运行状态。另外HandlerThread是Thread的一个子类，这种类型的线程能确保消息队列中的每个请求按照先进先出的顺序执行。在启动LauncherModel的工作线程后，紧接着LauncherModel还接管了工作线程的消息队列 如下： 1@Thunk static final Handler sWorker = new Handler(sWorkerThread.getLooper()); 当完成以上一系列动作后，LauncherModel就完成了对工作线程的初始化，这个线程将会一直处于消息等待状态，等待每一个刷新请求，支持LauncherModel的工作线程创建并且启动完成。 ④ LauncherModel的主线程处理器 LauncherModel的sWorkerThread是主线程下的一个子线程，它负责接收来自Launcher应用程序组件的刷新请求，对于sWorkerThread而言，在处理任务的同时也需要与Launcher有所交互，比如sWorkerThread需要将处理进程消息通过Launcher注册到LauncherModel中的接口通知Launcher，以便Launcher做出必要的响应。 那么现在的问题就是Launcher和LauncherModel运行在Launcher这个应用程序的主线程中（这个线程由Android框架维护） sWorkerThread只是Launcher应用程序主线程下的一个子线程，对于线程和线程之间的消息交互，一个比较好的方案是将任务抛到目标线程的处理器中，为此，LauncherModel为sWorkerThread在主线程中创建了一个处理器，以实现sWorkerThread和Launcher所在进程之间的信息交互。代码如下 1DeferredHandler mHandler = new DeferredHandler(); 这里引入了一个定义在LauncherModel外面而在LauncherModel中使用的线程处理器工具DeferredHandler。 接下来看下它的实现原理 DeferredHandler被当做主线程的处理器实例化在LauncherModel中，作为处理器，它需要满足通用处理器的一些定制化特性，因此它定义了一些嵌套类来满足这些特性。 Impl类 它首先是被定义在DeferredHandler的一个嵌套类。 1class Impl extends Handler implements MessageQueue.IdleHandler &#123; 作为handler的子类，它主要被用于处理发往主线程的消息。 IdleRunnable类 IdleRunnable是DeferredHandler内部的另外一个嵌套类，它是一个实现了Run那边了接口的类 1234567891011private class IdleRunnable implements Runnable &#123; Runnable mRunnable; IdleRunnable(Runnable r) &#123; mRunnable = r; &#125; public void run() &#123; mRunnable.run(); &#125; &#125; 由它的构造函数以及实现的run接口可知，它实际上只是Runnable的简单实现。这些类的具体使用我们后续继续分析。 好了 今天主要看了LauncherModel的创建，实例化（构造函数）和与LauncherModel的通信方式。 终于可以歇口气了。","tags":[]},{"title":"","date":"2017-03-01T02:27:05.304Z","path":"2017/03/01/android自定义View之3D索引效果/","text":"效果图： 我的小霸王太卡了。 最近工作比较忙，今天搞了一下午才搞出来这个效果，这种效果有很多种实现方式，最常见的应该是用贝塞尔曲线实现的。今天我们来看另一种不同的实现方式，只需要用到 canvas.scale()，有没有很好奇是怎么实现的呢。 首先来说一下思路，只要有了思路剩下的就是往里面套代码了。 通过观察上面的效果图我们发现可以把右边的字母分为三种类型1、 手指没触摸的地方显示正常的样式2、手指触摸的位置 显示最大且完全不透明3、手指触摸位置的上下附近位置 有放大且有透明度变化 对这个效果有了直观的认识后，我们就可以在ondraw里面根据不同的条件来分别画出这三种状态，这里主要难理解的就是这些条件。这需要结合代码看下。 so 我们开始撸码吧， 1、先初始化一些需要的变量 1234567891011121314private void init(Context context) &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setColor(Color.GRAY); mLetters = context.getResources().getStringArray(R.array.letter_list); mPaint.setTextAlign(Paint.Align.CENTER); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); mDensity = getContext().getResources().getDisplayMetrics().density; setPadding(0,dip2px(20),0,dip2px(20)); &#125;private int dip2px(int dipPx)&#123; return (int)(dipPx*mDensity+0.5); &#125; 相信上面这些应该没什么难度吧。另外把一些需要的宽高属性赋值一下，因为下面会用到它们 1234567891011@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mHeight = h - getPaddingTop() - getPaddingBottom(); mWidth = w - dip2px(16); mLetterHeight = mHeight / mLetters.length; int textSize = (int)(mLetterHeight*0.7); mPaint.setTextSize(textSize); mIsDownRect.set(w-dip2px(32),0,w,h); &#125; 这里主要就是mIsDownRect这个要注意一下它是索引列表的范围，但是我们并不需要画出它。2、在ontouch方法中对触摸事件进行必要的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); switch (action)&#123; case MotionEvent.ACTION_DOWN: mIsBeingDragger = false; float initDownY = event.getY(); if(!mIsDownRect.contains(event.getX(),event.getY()))&#123; return false; &#125; mInitDownY = initDownY; break; case MotionEvent.ACTION_MOVE: float y = event.getY(); float diff = Math.abs(y - mInitDownY); if(diff&gt;mTouchSlop&amp;&amp;!mIsBeingDragger)&#123; mIsBeingDragger = true; &#125; if(mIsBeingDragger)&#123; mY = y; float moveY = y - getPaddingTop(); int chartIndex = (int) (moveY / mHeight * mLetters.length);//获取索引位置的index if(mChoose!=chartIndex)&#123; if(chartIndex&gt;=0&amp;&amp;chartIndex&lt;mLetters.length) &#123; if (slidViewListener != null) &#123; Log.i(&quot;lly&quot;,&quot;chartIndex = &quot;+chartIndex); slidViewListener.onChange(mLetters[chartIndex]); &#125; mChoose = chartIndex; &#125; &#125; invalidate(); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mIsBeingDragger = false; mChoose = -1; invalidate(); break; &#125; return true; &#125; 这里面也很简单，首先当手指按下时记录下按下位置的Y坐标，然后判断按下的位置是否在索引列表的区域范围内(索引的区域在初始化赋值的时候已经确定过了)如果不在就没必要执行下去了 直接返回false即可，然后在手指移动的时候判断下是否是在移动是的话就把mIsBeingDragger置为true，如果mIsBeingDragger为true说明正在移动 ，这时候就计算出当前手指所在的索引位置，并通过回调方式通知外面当前的位置，最后把索引位置赋给全局变量mChoose，并刷新UI。手指抬起时进行一些复位操作。以上就是ontouch的全部方法。 3、在ondraw方法里面画出索引字母 这里要画出那三种类型的字母索引，我们先从简单的来 123456789float lettersPos= mLetterHeight*(i+1)+getPaddingTop(); //下一个字母的Y值坐标 float diffY; // Y 方向的偏移量 float diffX;//X 方向的偏移量 float diff;//缩放比例if (mChoose == i&amp;&amp;i!=0&amp;&amp;i!=mLetters.length-1) &#123; diff = 2.2f; diffX=0f; diffY=0f;&#125; mChoose 是在ontouch中我们记录的索引位置，当上面条件成立时说明当前就是选中的字母，这时候让它缩放比例最大，偏移量我们会在下面统一处理。接下来处理不是选中的情况 1234567891011121314151617float distanseDiff = Math.abs((mY - lettersPos)/mHeight);//计算手指触摸位置的上下附近位置 float maxPos = distanseDiff * 7;//乘7是因为这个系数太小了需要给他一个放大 if(distanseDiff&lt;0.174)&#123; diff = 2.2f - maxPos; &#125;else &#123; diff = 1f; &#125; if(!mIsBeingDragger)&#123; diff =1; &#125; diffX = maxPos * 50; if(mY&gt;lettersPos)&#123; diffY = maxPos*50; &#125;else &#123; diffY = - maxPos*50; &#125; 这里主要就是那个缩放系数比较难算 需要多试下。X Y方向的偏移量如下图 这些都计算好后就可以画了 123456789101112131415161718canvas.save(); canvas.scale(diff,diff,mWidth*1.2f+diffX,lettersPos+diffY); if(diff ==1)&#123; mPaint.setAlpha(255); mPaint.setTypeface(Typeface.DEFAULT); &#125;else &#123; int alpha = (int) (255*(1-Math.min(0.9,diff -1))); if(mChoose == i)&#123; alpha = 255; &#125; mPaint.setAlpha(alpha); mPaint.setTypeface(Typeface.DEFAULT_BOLD); &#125; Log.i(&quot;lly&quot;,&quot;mLetters[&quot;+i+&quot;] = &quot; +mLetters[i] ); canvas.drawText(mLetters[i],mWidth,lettersPos,mPaint); canvas.restore(); 可以发现canvas.scale(diff,diff,mWidth*1.2f+diffX,lettersPos+diffY); 这一句才是整个自定义view的关键 它前两个参数是x轴和y轴的缩放系数，后两个参数是x轴和y轴的锚点，我主要是试出来的,这两个参数比较难理解,还需要多家学习。到这里就已经实现了我们最上面的效果了。 源码","tags":[]},{"title":"","date":"2017-03-01T02:25:02.408Z","path":"2017/03/01/Android RRO机制的运用-----google开机向导客制化/","text":"上周五的时候领导分了一个任务，客户让在google开机向导里面增加一页，首先就想到了android的Overlay，然后网上搜了下，发下有很多人写了这方面的技术。而且写的都还不错，所以本篇只当记录作用吧，列下写的比较好的博客： http://developer.sonymobile.com/2014/04/22/sony-contributes-runtime-resource-overlay-framework-to-android-code-example/ 看情况大家应该都参考的这篇，英文好的可以看下。 Android 运行时资源替换—-Runtime Resource Overlay 既然原理别人都已经写好了，再写就有点浪费时间了，不懂的话可以参考上面两篇博客。 下面直接开始我这个功能的实现。 首先看下我们的基本思路，（解释一点 其实google的开机向导很多页面都来自不同的app） 1、所以我们先要找到把每一页整合到一起的配置文件， 2、找到这个配置文件后在相应的地方增加我们的页面配置。 后面的事就是编写UI之类的 根据需求来就可以了 1、查找配置文件 通过反编译工具可以把SetupWizard的资源文件反编译出来，android的配置文件一般都是xml文件 。所以到现在我们应该已经得到了SetupWizard的配置文件，这个配置文件具体是什么。请往下看。 通过sdk提供的hierarchyviewer工具我们可以得到SetupWizard每个页面的包名 注意到BluOOBEKeepActivity 和BluOOBEActiviy就是我添加的，先忽略掉它们，设置wifi的时候老是跳过 ，下面这张图是走到设置wifi界面的时候截的。 通过上图我们可以知道SetupWizard会走到Setting中去选择连接wifi的界面，别的包名看起来都是google的，google的应用我们一般都没源码，所以就以Settings的这个界面入手，看Settings中AndroidManifest.xml关于WifiSetupActivity的配置 1234567891011121314&lt;activity android:name=&quot;.wifi.WifiSetupActivity&quot; android:taskAffinity=&quot;com.android.wizard&quot; android:theme=&quot;@style/SetupWizardDisableAppStartingTheme&quot; android:label=&quot;@string/wifi_setup_wizard_title&quot; android:icon=&quot;@drawable/empty_icon&quot; android:clearTaskOnLaunch=&quot;true&quot; android:windowSoftInputMode=&quot;adjustNothing&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;com.android.net.wifi.SETUP_WIFI_NETWORK&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.settings.PRIMARY_PROFILE_CONTROLLED&quot; android:value=&quot;true&quot; /&gt; &lt;/activity&gt; 搜索这些信息发现SetupWizard的资源中并没有找到，很郁闷 ，没办法 唯一的思路不能断呀，只能一路查找它的父类 最后终于在WifiSettingsActivity 中找到了有用的信息 1&lt;action android:name=&quot;android.settings.WIFI_SETTINGS&quot; /&gt; 打开这两个文件查看，基本类似的，只是一个多了user，不知道具体有什么差别，但是通过对比发现 它们基本一样 只是wizard_script比wizard_script_user多了好多页面，但是明显第一个有welcome的页面，第二个没有，所以最终决定在wizard_script添加我们的页面。 123&lt;WizardAction wizard:uri=&quot;intent:#Intent;action=android.settings.SET_BLUOOBEKEEP;end&quot; id=&quot;blu_oobekeep&quot;&gt; &lt;result wizard:action=&quot;restore_check&quot; /&gt; &lt;/WizardAction&gt; 好了 经过比较蛋疼的查找后终于知道了要把新页面添加到什么地方， 接下来就是添加页面了。 2、最后也决定把这个页面写到Setting中，具体的内容的话就要看各个需求了。 Settings中AndroidManifest添加配置 12345678910&lt;activity android:name=&quot;com.android.settings.wifi.BluOOBEKeepActivity&quot; android:theme=&quot;@style/SetupWizardTheme.Light&quot; android:taskAffinity=&quot;com.android.wizard&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;action android:name=&quot;android.settings.SET_BLUOOBEKEEP&quot; /&gt; &lt;action android:name=&quot;android.settings.SET_BLUOOBE_NOT_ACCOUNTKEEP&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 源码","tags":[]},{"title":"Hello World","date":"2017-02-28T07:09:17.626Z","path":"2017/02/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]